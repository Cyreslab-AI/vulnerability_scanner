import argparse
import json
import requests
import os
import sys
from packaging import version
import yaml
from jinja2 import Template
import networkx as nx
from collections import deque

ECOSYSTEM_FILE_MAPPING = {
    'PyPI': ['requirements.txt', 'setup.py', 'pyproject.toml'],
    'npm': ['package.json', 'package-lock.json'],
    'RubyGems': ['Gemfile', 'Gemfile.lock'],
    'Maven': ['pom.xml']
}

def load_config(config_file):
    with open(config_file, 'r') as f:
        return yaml.safe_load(f)

def get_project_dependencies(file_path, ecosystem):
    if ecosystem == 'PyPI':
        return get_python_dependencies(file_path)
    elif ecosystem == 'npm':
        return get_npm_dependencies(file_path)
    elif ecosystem == 'RubyGems':
        return get_ruby_dependencies(file_path)
    elif ecosystem == 'Maven':
        return get_maven_dependencies(file_path)
    else:
        raise ValueError(f"Unsupported ecosystem: {ecosystem}")

def get_python_dependencies(file_path):
    dependencies = {}
    with open(file_path, 'r') as f:
        for line in f:
            if '==' in line:
                package, version = line.strip().split('==')
                dependencies[package] = version
    return dependencies

def get_npm_dependencies(file_path):
    with open(file_path, 'r') as f:
        data = json.load(f)
    return data.get('dependencies', {})

def get_ruby_dependencies(file_path):
    dependencies = {}
    with open(file_path, 'r') as f:
        for line in f:
            if line.strip().startswith('gem'):
                parts = line.split("'")
                if len(parts) >= 3:
                    dependencies[parts[1]] = parts[3] if len(parts) >= 4 else 'latest'
    return dependencies

def get_maven_dependencies(file_path):
    # This would require XML parsing, which is omitted for brevity
    return {}

def detect_dependency_file(directory):
    for ecosystem, files in ECOSYSTEM_FILE_MAPPING.items():
        for file in files:
            if os.path.exists(os.path.join(directory, file)):
                return ecosystem, os.path.join(directory, file)
    return None, None

def check_vulnerabilities(package_name, package_version, ecosystem):
    vulnerabilities = []
    
    # Check OSV database
    osv_vulns = check_osv_vulnerabilities(package_name, package_version, ecosystem)
    vulnerabilities.extend(osv_vulns)
    
    # Check NVD database
    nvd_vulns = check_nvd_vulnerabilities(package_name, package_version, ecosystem)
    vulnerabilities.extend(nvd_vulns)
    
    return vulnerabilities

def check_osv_vulnerabilities(package_name, package_version, ecosystem):
    base_url = "https://api.osv.dev/v1/query"
    data = {
        "package": {
            "name": package_name,
            "ecosystem": ecosystem
        },
        "version": package_version
    }
    
    try:
        response = requests.post(base_url, json=data)
        response.raise_for_status()
        vulnerabilities = response.json().get("vulns", [])
    except requests.RequestException as e:
        print(f"Error fetching data from OSV API: {e}")
        return []
    
    return [
        {
            "id": vuln["id"],
            "description": vuln.get("summary", "No description available"),
            "severity": vuln.get("database_specific", {}).get("severity", "UNKNOWN"),
            "fixed_version": get_fixed_version(vuln),
            "affected_versions": get_affected_versions(vuln),
            "source": "OSV"
        } for vuln in vulnerabilities
    ]

def check_nvd_vulnerabilities(package_name, package_version, ecosystem):
    # This is a placeholder. Implement actual NVD API call here.
    # You'll need to sign up for an API key and use their REST API.
    return []

def get_fixed_version(vulnerability):
    for affected in vulnerability.get("affected", []):
        for range_event in affected.get("ranges", []):
            for event in range_event.get("events", []):
                if event.get("fixed"):
                    return event["fixed"]
    return None

def get_affected_versions(vulnerability):
    affected_versions = []
    for affected in vulnerability.get("affected", []):
        for range_event in affected.get("ranges", []):
            if range_event.get("type") == "SEMVER":
                affected_versions.extend(range_event.get("events", []))
    return affected_versions

def is_version_in_range(version_to_check, affected_versions):
    for event in affected_versions:
        if "introduced" in event and version.parse(version_to_check) >= version.parse(event["introduced"]):
            if "fixed" in event and version.parse(version_to_check) < version.parse(event["fixed"]):
                return True
            elif "fixed" not in event:
                return True
    return False

def build_dependency_tree(dependencies, ecosystem):
    G = nx.DiGraph()
    for package, ver in dependencies.items():
        G.add_node(package, version=ver)
        sub_deps = get_project_dependencies(f"{package}-{ver}.json", ecosystem)  # This is a placeholder. You'd need to implement fetching subdependencies.
        for sub_package, sub_ver in sub_deps.items():
            G.add_edge(package, sub_package)
            G.nodes[sub_package]['version'] = sub_ver
    return G

def generate_html_report(results, dep_tree, output_file):
    template = Template("""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Vulnerability Report</title>
        <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 800px; margin: 0 auto; padding: 20px; }
            h1 { color: #2c3e50; }
            h2 { color: #34495e; }
            .vulnerability { background-color: #f9f9f9; border: 1px solid #ddd; padding: 10px; margin-bottom: 10px; }
            .severity-CRITICAL { border-left: 5px solid #e74c3c; }
            .severity-HIGH { border-left: 5px solid #e67e22; }
            .severity-MODERATE { border-left: 5px solid #f1c40f; }
            .severity-LOW { border-left: 5px solid #3498db; }
            .dep-tree { font-family: monospace; }
        </style>
    </head>
    <body>
        <h1>Vulnerability Report</h1>
        <h2>Dependency Tree</h2>
        <pre class="dep-tree">{{ dep_tree }}</pre>
        <h2>Vulnerabilities</h2>
        {% for package, data in results.items() %}
            <h3>{{ package }} (version: {{ data.version }})</h3>
            {% if data.vulnerabilities %}
                {% for vuln in data.vulnerabilities %}
                    <div class="vulnerability severity-{{ vuln.severity }}">
                        <h4>{{ vuln.id }} ({{ vuln.source }})</h4>
                        <p><strong>Severity:</strong> {{ vuln.severity }}</p>
                        <p><strong>Description:</strong> {{ vuln.description }}</p>
                        <p><strong>Affected Versions:</strong> {{ vuln.affected_versions|join(', ') }}</p>
                        {% if vuln.fixed_version %}
                            <p><strong>Fixed in version:</strong> {{ vuln.fixed_version }}</p>
                        {% endif %}
                    </div>
                {% endfor %}
            {% else %}
                <p>No vulnerabilities found.</p>
            {% endif %}
        {% endfor %}
    </body>
    </html>
    """)
    
    dep_tree_str = "\n".join([f"{'  ' * depth}{node}" for node, depth in nx.bfs_successors(dep_tree, dep_tree.nodes[0])])
    html_content = template.render(results=results, dep_tree=dep_tree_str)
    with open(output_file, 'w') as f:
        f.write(html_content)

def main():
    parser = argparse.ArgumentParser(description="Analyze frameworks and libraries for vulnerabilities")
    parser.add_argument("--config", help="Path to configuration file")
    parser.add_argument("--dependencies", help="Path to the dependencies file")
    parser.add_argument("--ecosystem", choices=["PyPI", "npm", "RubyGems", "Maven"], help="Package ecosystem")
    parser.add_argument("--output", choices=["text", "json", "html"], default="text", help="Output format (default: text)")
    parser.add_argument("--min-severity", choices=["LOW", "MODERATE", "HIGH", "CRITICAL"], default="LOW", help="Minimum severity level to report")
    args = parser.parse_args()

    if args.config:
        config = load_config(args.config)
        args.dependencies = config.get("dependencies_file", args.dependencies)
        args.ecosystem = config.get("ecosystem", args.ecosystem)
        args.output = config.get("output_format", args.output)
        args.min_severity = config.get("min_severity", args.min_severity)

    if not args.dependencies:
        print("Attempting to auto-detect dependency file...")
        args.ecosystem, args.dependencies = detect_dependency_file(".")
        if not args.dependencies:
            print("Error: Could not detect dependency file. Please specify it manually.")
            sys.exit(1)
        print(f"Detected {args.ecosystem} ecosystem, using file: {args.dependencies}")

    if not args.ecosystem:
        print("Error: Ecosystem must be specified either in config or as a command-line argument.")
        sys.exit(1)

    try:
        dependencies = get_project_dependencies(args.dependencies, args.ecosystem)
    except FileNotFoundError:
        print(f"Error: Dependencies file not found: {args.dependencies}")
        sys.exit(1)

    dep_tree = build_dependency_tree(dependencies, args.ecosystem)

    results = {}
    severity_levels = ["LOW", "MODERATE", "HIGH", "CRITICAL"]
    min_severity_index = severity_levels.index(args.min_severity)

    for package, version in nx.get_node_attributes(dep_tree, 'version').items():
        print(f"Checking vulnerabilities for {package} (version: {version})...")
        vulnerabilities = check_vulnerabilities(package, version, args.ecosystem)
        filtered_vulnerabilities = [
            v for v in vulnerabilities 
            if severity_levels.index(v["severity"]) >= min_severity_index
            and is_version_in_range(version, v["affected_versions"])
        ]
        if filtered_vulnerabilities:
            results[package] = {
                "version": version,
                "vulnerabilities": filtered_vulnerabilities
            }

    if args.output == "json":
        print(json.dumps(results, indent=2))
    elif args.output == "html":
        html_file = "vulnerability_report.html"
        generate_html_report(results, dep_tree, html_file)
        print(f"HTML report generated: {html_file}")
    else:
        if results:
            for package, data in results.items():
                print(f"Package: {package} (version: {data['version']})")
                print("Vulnerabilities:")
                for vuln in data['vulnerabilities']:
                    print(f"  - {vuln['id']} (Severity: {vuln['severity']}, Source: {vuln['source']})")
                    print(f"    Description: {vuln['description']}")
                    print(f"    Affected Versions: {', '.join(map(str, vuln['affected_versions']))}")
                    if vuln['fixed_version']:
                        print(f"    Fixed in version: {vuln['fixed_version']}")
                print()
        else:
            print("No vulnerabilities found meeting the specified severity threshold.")

    if results:
        sys.exit(1)  # Exit with non-zero status if vulnerabilities are found
    else:
        sys.exit(0)

if __name__ == "__main__":
    main()