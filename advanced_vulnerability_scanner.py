import argparse
import json
import requests
import os
import sys
from packaging import version
import yaml
from jinja2 import Template
import networkx as nx
import matplotlib.pyplot as plt
from rich.console import Console
from rich.table import Table
from rich.progress import track
import docker
import schedule
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import joblib
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer

# ... (previous imports and constants)

class VulnerabilityScanner:
    def __init__(self, config):
        self.config = config
        self.console = Console()
        self.dependency_graph = nx.DiGraph()
        self.ml_model = self.load_ml_model()

    def load_ml_model(self):
        model_path = 'vulnerability_prediction_model.joblib'
        if os.path.exists(model_path):
            return joblib.load(model_path)
        else:
            # Train a simple model if it doesn't exist
            # This is a placeholder and should be replaced with a properly trained model
            vectorizer = TfidfVectorizer()
            classifier = RandomForestClassifier()
            X = vectorizer.fit_transform(["sample vulnerability description"])
            y = [1]  # 1 for vulnerable, 0 for not vulnerable
            classifier.fit(X, y)
            joblib.dump((vectorizer, classifier), model_path)
            return vectorizer, classifier

    def get_project_dependencies(self, file_path, ecosystem):
        # ... (implementation from previous version)

    def check_vulnerabilities(self, package_name, package_version, ecosystem):
        # ... (implementation from previous version)

    def analyze_dependency_graph(self):
        for package, data in self.dependencies.items():
            self.dependency_graph.add_node(package, version=data['version'])
            for dep, dep_data in data.get('dependencies', {}).items():
                self.dependency_graph.add_edge(package, dep)

        plt.figure(figsize=(12, 8))
        pos = nx.spring_layout(self.dependency_graph)
        nx.draw(self.dependency_graph, pos, with_labels=True, node_color='lightblue', node_size=500, font_size=8, font_weight='bold')
        nx.draw_networkx_labels(self.dependency_graph, pos, {node: f"{node}\n{self.dependency_graph.nodes[node]['version']}" for node in self.dependency_graph.nodes()})
        plt.title("Dependency Graph")
        plt.savefig("dependency_graph.png")
        plt.close()

    def predict_vulnerability(self, package_name, package_version):
        vectorizer, classifier = self.ml_model
        feature_vector = vectorizer.transform([f"{package_name} {package_version}"])
        prediction = classifier.predict(feature_vector)
        return prediction[0] == 1

    def scan_docker_image(self, image_name):
        client = docker.from_env()
        image = client.images.pull(image_name)
        history = image.history()
        vulnerabilities = []

        for layer in history:
            if 'Created' in layer and layer['Created']:
                # Check for vulnerabilities in the layer's creation command
                if self.predict_vulnerability(layer['CreatedBy'], ''):
                    vulnerabilities.append({
                        'layer': layer['Id'],
                        'command': layer['CreatedBy'],
                        'created': layer['Created']
                    })

        return vulnerabilities

    def check_license_compliance(self, package_name, package_version):
        # This is a simplified check. In a real-world scenario, you'd want to use a comprehensive license database.
        license_url = f"https://pypi.org/pypi/{package_name}/{package_version}/json"
        response = requests.get(license_url)
        if response.status_code == 200:
            data = response.json()
            license = data['info']['license']
            return license in self.config.get('allowed_licenses', ['MIT', 'Apache-2.0', 'BSD'])
        return False

    def generate_report(self, results):
        table = Table(title="Vulnerability Report")
        table.add_column("Package", style="cyan")
        table.add_column("Version", style="magenta")
        table.add_column("Vulnerabilities", style="red")
        table.add_column("License Compliant", style="green")

        for package, data in results.items():
            vulnerabilities = len(data['vulnerabilities'])
            license_compliant = "Yes" if self.check_license_compliance(package, data['version']) else "No"
            table.add_row(package, data['version'], str(vulnerabilities), license_compliant)

        self.console.print(table)

        # Generate HTML report
        # ... (implementation from previous version)

    def send_alert(self, message):
        sender_email = self.config['alert_email']['sender']
        receiver_email = self.config['alert_email']['receiver']
        password = self.config['alert_email']['password']

        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = receiver_email
        msg['Subject'] = "Vulnerability Alert"

        msg.attach(MIMEText(message, 'plain'))

        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(sender_email, password)
            server.send_message(msg)

    def continuous_monitoring(self):
        def job():
            results = self.scan()
            if any(result['vulnerabilities'] for result in results.values()):
                self.send_alert("New vulnerabilities detected! Please check the latest scan results.")

        schedule.every(self.config.get('monitoring_interval', 24)).hours.do(job)

        while True:
            schedule.run_pending()
            time.sleep(1)

    def scan(self):
        self.console.print("[bold green]Starting vulnerability scan...[/bold green]")

        self.dependencies = self.get_project_dependencies(self.config['dependencies_file'], self.config['ecosystem'])
        results = {}

        for package, version in track(self.dependencies.items(), description="Scanning packages..."):
            self.console.print(f"Checking vulnerabilities for [cyan]{package}[/cyan] (version: [magenta]{version}[/magenta])...")
            vulnerabilities = self.check_vulnerabilities(package, version, self.config['ecosystem'])
            docker_vulnerabilities = self.scan_docker_image(f"{package}:{version}") if self.config.get('scan_docker', False) else []
            
            if vulnerabilities or docker_vulnerabilities or self.predict_vulnerability(package, version):
                results[package] = {
                    "version": version,
                    "vulnerabilities": vulnerabilities + docker_vulnerabilities
                }

        self.analyze_dependency_graph()
        self.generate_report(results)

        return results

def main():
    parser = argparse.ArgumentParser(description="Advanced Vulnerability Scanner")
    parser.add_argument("--config", default="config.yaml", help="Path to configuration file")
    args = parser.parse_args()

    with open(args.config, 'r') as f:
        config = yaml.safe_load(f)

    scanner = VulnerabilityScanner(config)
    
    if config.get('continuous_monitoring', False):
        scanner.continuous_monitoring()
    else:
        scanner.scan()

if __name__ == "__main__":
    main()